version: 0.2

env:
  variables:
    AWS_REGION: us-east-1
    ECR_REPO: secure-health-api
    CONTAINER_NAME: secure-health-api
    FAIL_ON_HIGH: "0"
    HIGH_THRESHOLD: "3"
    TASK_ROLE_NAME: ecsTaskRole-secure-health-api
    EXEC_ROLE_NAME: ecsTaskExecutionRole-secure-health-api
    IAM_WILDCARD_RESOURCE_ALLOWLIST: arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy

phases:
  pre_build:
    commands:
      - echo "Logging in to ECR..."
      - AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
      - REPO_URI=${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO}
      - COMMIT_SHA=${CODEBUILD_RESOLVED_SOURCE_VERSION}
      - IMAGE_TAG=${COMMIT_SHA:0:7}-${CODEBUILD_BUILD_NUMBER}
      - aws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com
      - 'echo "Repo URI: ${REPO_URI}"'
      - 'echo "Image tag: ${IMAGE_TAG}"'

  build:
    commands:
      - echo "Building Docker image..."
      - docker build -t ${REPO_URI}:${IMAGE_TAG} ./app

  post_build:
    commands:
      - echo "Pushing Docker image..."
      - docker push ${REPO_URI}:${IMAGE_TAG}

      - echo "Waiting for ECR image scan to complete..."
      - |
          set -e
          for i in $(seq 1 30); do
            STATUS=$(aws ecr describe-images \
              --region ${AWS_REGION} \
              --repository-name ${ECR_REPO} \
              --image-ids imageTag=${IMAGE_TAG} \
              --query 'imageDetails[0].imageScanStatus.status' \
              --output text || echo "UNKNOWN")
            echo "Scan status: ${STATUS} (attempt ${i}/30)"
            if [ "${STATUS}" = "COMPLETE" ]; then
              break
            fi
            if [ "${STATUS}" = "FAILED" ]; then
              echo "ECR scan FAILED"
              exit 1
            fi
            sleep 5
          done

      - echo "Fetching scan findings summary..."
      - |
          set -e
          CRITICAL=$(aws ecr describe-image-scan-findings \
            --region ${AWS_REGION} \
            --repository-name ${ECR_REPO} \
            --image-id imageTag=${IMAGE_TAG} \
            --query 'imageScanFindings.findingSeverityCounts.CRITICAL' \
            --output text 2>/dev/null || echo "0")
          HIGH=$(aws ecr describe-image-scan-findings \
            --region ${AWS_REGION} \
            --repository-name ${ECR_REPO} \
            --image-id imageTag=${IMAGE_TAG} \
            --query 'imageScanFindings.findingSeverityCounts.HIGH' \
            --output text 2>/dev/null || echo "0")

          if [ "${CRITICAL}" = "None" ]; then CRITICAL=0; fi
          if [ "${HIGH}" = "None" ]; then HIGH=0; fi

          echo "ECR findings: CRITICAL=${CRITICAL}, HIGH=${HIGH}"

          if [ "${CRITICAL}" -gt 0 ]; then
            echo "FAIL: CRITICAL findings > 0"
            exit 1
          fi

          if [ "${FAIL_ON_HIGH}" = "1" ] && [ "${HIGH}" -gt "${HIGH_THRESHOLD}" ]; then
            echo "FAIL: HIGH findings (${HIGH}) exceed threshold (${HIGH_THRESHOLD})"
            exit 1
          fi

          echo "PASS: ECR scan gate satisfied."

      - echo "Running IAM wildcard gate (no Action:* ; Resource:* only if allowlisted)..."
      - |
          set -e

          check_policy_doc () {
            python3 - << 'PY'
import json, sys

policy = json.load(sys.stdin)

def has_star(val):
    if isinstance(val, str):
        return val.strip() == "*"
    if isinstance(val, list):
        return any(isinstance(v, str) and v.strip() == "*" for v in val)
    return False

bad = set()

for stmt in policy.get("Statement", []):
    stmts = [stmt] if isinstance(stmt, dict) else stmt
    for s in stmts:
        if s.get("Effect") != "Allow":
            continue

        action = s.get("Action") or s.get("NotAction")
        resource = s.get("Resource") or s.get("NotResource")

        if has_star(action):
            bad.add("Action:*")
        if has_star(resource):
            bad.add("Resource:*")

if bad:
    print("FOUND:", ", ".join(sorted(bad)))
    sys.exit(2)

print("OK")
PY
          }

          is_allowlisted_policy () {
            IFS=',' read -ra ALLOW <<< "${IAM_WILDCARD_RESOURCE_ALLOWLIST}"
            for a in "${ALLOW[@]}"; do
              if [ "$1" = "$a" ]; then
                return 0
              fi
            done
            return 1
          }

          check_role () {
            ROLE_NAME="$1"
            echo "Checking role: ${ROLE_NAME}"

            # Inline policies (strict: no Resource:* allowed here)
            INLINE=$(aws iam list-role-policies --role-name "${ROLE_NAME}" --query 'PolicyNames' --output text)
            if [ "${INLINE}" != "None" ] && [ -n "${INLINE}" ]; then
              for PNAME in ${INLINE}; do
                echo " - Inline policy: ${PNAME}"
                aws iam get-role-policy --role-name "${ROLE_NAME}" --policy-name "${PNAME}" --query 'PolicyDocument' --output json > /tmp/role-inline.json
                if ! cat /tmp/role-inline.json | check_policy_doc; then
                  echo "FAIL: Wildcards found in inline policy ${PNAME} on ${ROLE_NAME}"
                  exit 1
                fi
              done
            fi

            # Attached managed policies
            aws iam list-attached-role-policies --role-name "${ROLE_NAME}" --query 'AttachedPolicies[].PolicyArn' --output text | tr '\t' '\n' > /tmp/attached.txt || true
            while read -r POLICY_ARN; do
              [ -z "${POLICY_ARN}" ] && continue
              echo " - Attached policy: ${POLICY_ARN}"

              DEFAULT_VER=$(aws iam get-policy --policy-arn "${POLICY_ARN}" --query 'Policy.DefaultVersionId' --output text)
              aws iam get-policy-version --policy-arn "${POLICY_ARN}" --version-id "${DEFAULT_VER}" --query 'PolicyVersion.Document' --output json > /tmp/policy.json

              # Find wildcards
              OUT=$(cat /tmp/policy.json | python3 - << 'PY'
import json, sys
p=json.load(sys.stdin)

def has_star(v):
    if isinstance(v, str):
        return v.strip() == "*"
    if isinstance(v, list):
        return any(isinstance(x, str) and x.strip() == "*" for x in v)
    return False

bad=set()
for stmt in p.get("Statement", []):
    stmts=[stmt] if isinstance(stmt, dict) else stmt
    for st in stmts:
        if st.get("Effect") != "Allow":
            continue
        if has_star(st.get("Action") or st.get("NotAction")):
            bad.add("Action:*")
        if has_star(st.get("Resource") or st.get("NotResource")):
            bad.add("Resource:*")

print(",".join(sorted(bad)))
PY)

              if echo "${OUT}" | grep -q "Action:\*"; then
                echo "FAIL: Action:* found in managed policy ${POLICY_ARN}"
                exit 1
              fi

              if echo "${OUT}" | grep -q "Resource:\*"; then
                if is_allowlisted_policy "${POLICY_ARN}"; then
                  echo "   NOTE: Resource:* allowed for allowlisted policy ${POLICY_ARN}"
                else
                  echo "FAIL: Resource:* found in managed policy ${POLICY_ARN} (not allowlisted)"
                  exit 1
                fi
              fi

            done < /tmp/attached.txt
          }

          check_role "${TASK_ROLE_NAME}"
          check_role "${EXEC_ROLE_NAME}"

          echo "PASS: IAM wildcard gate satisfied."

      - echo "Writing imagedefinitions.json..."
      - printf '[{"name":"%s","imageUri":"%s"}]' "${CONTAINER_NAME}" "${REPO_URI}:${IMAGE_TAG}" > imagedefinitions.json
      - echo "Confirm artifact exists:"
      - ls -l imagedefinitions.json
      - cat imagedefinitions.json

artifacts:
  files:
    - imagedefinitions.json
